// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: film.sql

package repository

import (
	"context"
)

const CreateFilm = `-- name: CreateFilm :one
INSERT INTO film (title,director,genre_id,duration) SELECT $1,$2,$3,$4 
WHERE EXISTS(SELECT id FROM genre WHERE id = $3) RETURNING id
`

type CreateFilmParams struct {
	Title    string `json:"title"`
	Director string `json:"director"`
	GenreID  int64  `json:"genre_id"`
	Duration string `json:"duration"`
}

func (q *Queries) CreateFilm(ctx context.Context, arg CreateFilmParams) (int64, error) {
	row := q.db.QueryRow(ctx, CreateFilm,
		arg.Title,
		arg.Director,
		arg.GenreID,
		arg.Duration,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const DeleteFilm = `-- name: DeleteFilm :exec
DELETE FROM film WHERE id = $1
`

func (q *Queries) DeleteFilm(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeleteFilm, id)
	return err
}

const GetFilm = `-- name: GetFilm :one
SELECT film.id, film.title, film.director, genre.name AS genre, film.duration FROM film  
INNER JOIN genre  ON film.genre_id = genre.id WHERE film.id=$1
`

type GetFilmRow struct {
	ID       int64  `json:"id"`
	Title    string `json:"title"`
	Director string `json:"director"`
	Genre    string `json:"genre"`
	Duration string `json:"duration"`
}

func (q *Queries) GetFilm(ctx context.Context, id int64) (GetFilmRow, error) {
	row := q.db.QueryRow(ctx, GetFilm, id)
	var i GetFilmRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Director,
		&i.Genre,
		&i.Duration,
	)
	return i, err
}

const ListFilm = `-- name: ListFilm :many
SELECT film.id, film.title, film.director, genre.name AS genre, film.duration FROM film 
INNER JOIN genre ON film.genre_id = genre.id ORDER BY film.id ASC
`

type ListFilmRow struct {
	ID       int64  `json:"id"`
	Title    string `json:"title"`
	Director string `json:"director"`
	Genre    string `json:"genre"`
	Duration string `json:"duration"`
}

func (q *Queries) ListFilm(ctx context.Context) ([]ListFilmRow, error) {
	rows, err := q.db.Query(ctx, ListFilm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilmRow{}
	for rows.Next() {
		var i ListFilmRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Director,
			&i.Genre,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchFilm = `-- name: SearchFilm :many
SELECT film.id, film.title, film.director, genre.name AS genre, film.duration FROM film
INNER JOIN genre  ON film.genre_id = genre.id
WHERE film.title LIKE $1
`

type SearchFilmRow struct {
	ID       int64  `json:"id"`
	Title    string `json:"title"`
	Director string `json:"director"`
	Genre    string `json:"genre"`
	Duration string `json:"duration"`
}

func (q *Queries) SearchFilm(ctx context.Context, title string) ([]SearchFilmRow, error) {
	rows, err := q.db.Query(ctx, SearchFilm, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchFilmRow{}
	for rows.Next() {
		var i SearchFilmRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Director,
			&i.Genre,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchGenreFilm = `-- name: SearchGenreFilm :many
SELECT film.id, film.title, film.director, genre.name AS genre, film.duration FROM film  
INNER JOIN genre  ON film.genre_id = genre.id WHERE film.genre_id=(SELECT id FROM genre WHERE genre.id = $1)
`

type SearchGenreFilmRow struct {
	ID       int64  `json:"id"`
	Title    string `json:"title"`
	Director string `json:"director"`
	Genre    string `json:"genre"`
	Duration string `json:"duration"`
}

func (q *Queries) SearchGenreFilm(ctx context.Context, id int64) ([]SearchGenreFilmRow, error) {
	rows, err := q.db.Query(ctx, SearchGenreFilm, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchGenreFilmRow{}
	for rows.Next() {
		var i SearchGenreFilmRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Director,
			&i.Genre,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateFilm = `-- name: UpdateFilm :one
UPDATE film SET title=$2, director=$3, genre_id = $4, duration=$5 WHERE film.id = $1 
AND EXISTS(SELECT id FROM genre WHERE genre.id = $4) RETURNING film.id
`

type UpdateFilmParams struct {
	ID       int64  `json:"id"`
	Title    string `json:"title"`
	Director string `json:"director"`
	GenreID  int64  `json:"genre_id"`
	Duration string `json:"duration"`
}

func (q *Queries) UpdateFilm(ctx context.Context, arg UpdateFilmParams) (int64, error) {
	row := q.db.QueryRow(ctx, UpdateFilm,
		arg.ID,
		arg.Title,
		arg.Director,
		arg.GenreID,
		arg.Duration,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
