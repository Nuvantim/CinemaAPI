// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payment.sql

package repository

import (
	"context"
)

const CreatePayment = `-- name: CreatePayment :one
INSERT INTO payment (booking_id, user_id, payment_method, payment_status, transaction_amount, payment_time)
SELECT 
    b.id,
    b.user_id,
    $1,
    $2,
    b.total_amount,
    NOW()
FROM booking b
WHERE b.id = $3
RETURNING id, user_id, booking_id, payment_method, payment_status, transaction_amount, payment_time
`

type CreatePaymentParams struct {
	PaymentMethod string `json:"payment_method"`
	PaymentStatus string `json:"payment_status"`
	BookingID     int64  `json:"booking_id"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, CreatePayment, arg.PaymentMethod, arg.PaymentStatus, arg.BookingID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookingID,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.TransactionAmount,
		&i.PaymentTime,
	)
	return i, err
}

const ListPayment = `-- name: ListPayment :many
SELECT id, user_id, booking_id, payment_method, payment_status, transaction_amount, payment_time FROM payment WHERE user_id = $1 ORDER BY payment_time ASC
`

func (q *Queries) ListPayment(ctx context.Context, userID int64) ([]Payment, error) {
	rows, err := q.db.Query(ctx, ListPayment, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookingID,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.TransactionAmount,
			&i.PaymentTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
